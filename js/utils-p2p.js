"use strict";class PeerVe extends Peer{constructor(a){super(),this._role=a,this._connectionsArray=[],this._pInit=new Promise((a,b)=>{this.on("open",b=>a(b)),this.on("error",a=>b(a))})}get connections(){return this._connectionsArray}hasConnections(){return!!this._connectionsArray.length}getActiveConnections(){return this._connectionsArray.filter(a=>a.open)}pInit(){return this._pInit}sendMessage(a){if(this.disconnected||this.destroyed)throw new Error(`Connection is not active!`);const b={head:{type:this._role,version:"0.0.2"},data:a};this.getActiveConnections().forEach(a=>a.send(b))}}class PeerVeServer extends PeerVe{constructor(){super("server"),this.on("connection",a=>this._connectionsArray.push(a)),this._tempListeners={}}get token(){return this.id}onTemp(a,b){(this._tempListeners[a]=this._tempListeners[a]||[]).push(b),this.on(a,b)}offTemp(a){(this._tempListeners[a]||[]).forEach(b=>this.off(a,b))}}class PeerVeClient extends PeerVe{constructor(){super("client"),this._data=null}pConnectToServer(a,b,c=null){const d=c?this.connect(a,c):this.connect(a);return d.on("data",a=>b(a)),new Promise((a,b)=>{this.on("open",b=>a(b)),this.on("error",a=>b(a))})}}