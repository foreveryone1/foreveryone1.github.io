"use strict";class Ro_Token{constructor(a,b,c,d){this.type=a,this.value=b,this._asString=c,this.line=d}static _new(a,b){return new Ro_Token(a,null,b)}_(a){return new Ro_Token(this.type,this.value,this._asString,a)}eq(a){return a&&a.type===this.type}toString(){return this._asString?this._asString:this.toDebugString()}toDebugString(){return`${this.type}${this.value?` :: ${this.value}`:""}`}static NUMBER(a,b){return new Ro_Token(Ro_Token.TYP_NUMBER,a,null,b)}static IDENTIFIER(a,b){return new Ro_Token(Ro_Token.TYP_IDENTIFIER,a,null,b)}static DYNAMIC(a,b){return new Ro_Token(Ro_Token.TYP_DYNAMIC,a,null,b)}static SYMBOL(){}static UNPARSED(a,b){return new Ro_Token(Ro_Token.TYP_UNPARSED,a,null,b)}}Ro_Token.TYP_NUMBER="NUMBER",Ro_Token.TYP_IDENTIFIER="IDENTIFIER",Ro_Token.TYP_DYNAMIC="DYNAMIC",Ro_Token.TYP_SYMBOL="SYMBOL",Ro_Token.TYP_UNPARSED="UNPARSED",Ro_Token.NEWLINE=Ro_Token._new("NEWLINE","&lt;newline&gt;"),Ro_Token.INDENT=Ro_Token._new("INDENT","&lt;line_indent&gt;"),Ro_Token.DEDENT=Ro_Token._new("DEDENT","&lt;line_dedent&gt;"),Ro_Token.PAREN_OPEN=Ro_Token._new("PAREN_OPEN","("),Ro_Token.PAREN_CLOSE=Ro_Token._new("PAREN_CLOSE",")"),Ro_Token.IF=Ro_Token._new("IF","if"),Ro_Token.ELSE=Ro_Token._new("ELSE","else"),Ro_Token.ELIF=Ro_Token._new("ELIF","elif"),Ro_Token.EQ=Ro_Token._new("EQ","=="),Ro_Token.NE=Ro_Token._new("NE","!="),Ro_Token.GT=Ro_Token._new("GT",">"),Ro_Token.LT=Ro_Token._new("LT","<"),Ro_Token.GTEQ=Ro_Token._new("GTEQ",">="),Ro_Token.LTEQ=Ro_Token._new("LTEQ","<="),Ro_Token.NOT=Ro_Token._new("NOT","not"),Ro_Token.ADD=Ro_Token._new("ADD","+"),Ro_Token.SUB=Ro_Token._new("SUB","-"),Ro_Token.MULT=Ro_Token._new("MULT","*"),Ro_Token.DIV=Ro_Token._new("DIV","/"),Ro_Token.POW=Ro_Token._new("POW","^"),Ro_Token.COLON=Ro_Token._new("COLON",":"),Ro_Token.ASSIGN=Ro_Token._new("ASSIGN","=");class Ro_Lexer{constructor(){this._indentStack=null,this._tokenStack=[]}lex(a,b){b=b||{};const c=a.trimRight().split("\n").map(a=>a.trimRight()).filter(Boolean).filter(a=>!a.startsWith("#"));this._indentStack=[],this._tokenStack=[];for(const d of c)this._lexLine(d,b),this._tokenStack.push(Ro_Token.NEWLINE._(d));return[...Array(this._indentStack.length)].forEach(()=>this._tokenStack.push(Ro_Token.DEDENT)),this._tokenStack}_lexLine(a,b){b=b||{};let e=0,f=!0,g="",h=0,i=0,j=0,k=null;const l=()=>{if(g){if(b.isDynamicsOnly)g.startsWith("@")||g.startsWith("(@")?this._tokenStack.push(Ro_Token.DYNAMIC(g,a)):this._tokenStack.push(Ro_Token.UNPARSED(g,a));else switch(g){case"(":this._tokenStack.push(Ro_Token.PAREN_OPEN._(a));break;case")":this._tokenStack.push(Ro_Token.PAREN_CLOSE._(a));break;case"if":this._tokenStack.push(Ro_Token.IF._(a));break;case"else":this._tokenStack.push(Ro_Token.ELSE._(a));break;case"elif":this._tokenStack.push(Ro_Token.ELIF._(a));break;case"==":this._tokenStack.push(Ro_Token.EQ._(a));break;case"!=":this._tokenStack.push(Ro_Token.NE._(a));break;case">":this._tokenStack.push(Ro_Token.GT._(a));break;case"<":this._tokenStack.push(Ro_Token.LT._(a));break;case">=":this._tokenStack.push(Ro_Token.GTEQ._(a));break;case"<=":this._tokenStack.push(Ro_Token.LTEQ._(a));break;case"not":this._tokenStack.push(Ro_Token.NOT._(a));break;case"+":case"--":this._tokenStack.push(Ro_Token.ADD._(a));break;case"-":case"+-":case"-+":this._tokenStack.push(Ro_Token.SUB._(a));break;case"*":this._tokenStack.push(Ro_Token.MULT._(a));break;case"/":this._tokenStack.push(Ro_Token.DIV._(a));break;case"^":this._tokenStack.push(Ro_Token.POW._(a));break;case":":this._tokenStack.push(Ro_Token.COLON._(a));break;case"=":this._tokenStack.push(Ro_Token.ASSIGN._(a));break;default:if(g.startsWith("@")||g.startsWith("(@"))this._tokenStack.push(Ro_Token.DYNAMIC(g,a));else if(Ro_Lexer._M_IDENT.test(g))this._tokenStack.push(Ro_Token.IDENTIFIER(g,a));else if(Ro_Lexer._M_NUMBER.test(g))this._tokenStack.push(Ro_Token.NUMBER(g,a));else throw new Error(`Syntax error: unexpected token <code>${g}</code> (line <code>${a}</code>)`);}g=""}};outer:for(let m=0;m<a.length;++m){const n=a[m],c=a[m+1];if(f)if(" "===n||"\t"===n)e++;else{f=!1;const b=this._indentStack.last();if(null==b)0<e&&(this._indentStack.push(e),this._tokenStack.push(Ro_Token.INDENT._(a)));else if(e>b)this._indentStack.push(e),this._tokenStack.push(Ro_Token.INDENT._(a));else{let b,c=0;for(;this._indentStack.length&&(this._indentStack.pop(),c++,b=this._indentStack.last()||0,b!==e););if(b===e)[...Array(c)].forEach(()=>this._tokenStack.push(Ro_Token.DEDENT._(a)));else throw new Error(`Syntax error: no matching indent found for line <code>${a}</code>`)}}switch(n){case"#":if(b.isDynamicsOnly){g+=n;break}else break outer;case" ":{h?g+=n:b.isDynamicsOnly?g+=n:l();break}case":":{h?g+=n:b.isDynamicsOnly?g+=n:(l(),g=n,l());break}case"(":h?(h++,g+=n):"@"===c?(h++,l(),g+=n):b.isDynamicsOnly?g+=n:(i++,l(),g="(",l());break;case")":if(h)h--,g+=n,h||l();else if(b.isDynamicsOnly)g+=n;else{if(i--,0>i)throw new Error(`Syntax error: closing <code>)</code> without opening <code>(</code> in line <code>${a}</code>`);l(),g=")",l()}break;case"{":{h?g+=n:b.isDynamicsOnly?g+=n:(j++,l(),g="{",l());break}case"}":{if(h)g+=n;else if(b.isDynamicsOnly)g+=n;else{if(j--,0>j)throw new Error(`Syntax error: closing <code>}</code> without opening <code>{</code> in line <code>${a}</code>`);l(),g="}",l()}break}default:{if(h)g+=n;else if(b.isDynamicsOnly)"@"===n&&"("!==g.last()?(l(),g="@"):g+=n;else if(Ro_Lexer._M_TEXT_CHAR.test(n))"symbol"===k&&l(),g+=n,k="text";else if(Ro_Lexer._M_SYMBOL_CHAR.test(n))"text"===k&&l(),g+=n,k="symbol";else throw new Error(`Syntax error: unexpected character <code>${n}</code> in line <code>${a}</code>`);break}}}l()}}Ro_Lexer._M_TEXT_CHAR=/[a-zA-Z0-9_@]/,Ro_Lexer._M_SYMBOL_CHAR=/[-+/*^=!:><]/,Ro_Lexer._M_NUMBER=/^\d+$/,Ro_Lexer._M_IDENT=/^[a-zA-Z]\w*$/;class Ro_Parser{constructor(a){this._ixSym=-1,this._syms=a,this._sym=null,this._lastAccepted=null}_nextSym(){const a=this._syms[this._ixSym];return this._ixSym++,this._sym=this._syms[this._ixSym],a}_peek(){return this._syms[this._ixSym+1]}parse(){return this._nextSym(),this._block()}_match(a){return null!=this._sym&&(a.type&&(a=a.type),this._sym.type===a)}_accept(a){if(this._match(a)){const a=this._sym;return this._nextSym(),this._lastAccepted=a,a}return!1}_expect(a){const b=this._accept(a);if(b)return b;if(this._sym)throw new Error(`Unexpected input: Expected <code>${a}</code> but found <code>${this._sym}</code> (line <code>${this._sym.line}</code>)`);else throw new Error(`Unexpected end of input: Expected <code>${a}</code>`)}_factor(){if(this._accept(Ro_Token.TYP_IDENTIFIER))return new Ro_Parser._Factor(this._lastAccepted);if(this._accept(Ro_Token.TYP_NUMBER))return new Ro_Parser._Factor(this._lastAccepted);if(this._accept(Ro_Token.TYP_DYNAMIC))return new Ro_Parser._Factor(this._lastAccepted);if(this._accept(Ro_Token.PAREN_OPEN)){const a=this._expression();return this._expect(Ro_Token.PAREN_CLOSE),new Ro_Parser._Factor(a,{hasParens:!0})}if(this._sym)throw new Error(`Unexpected input: <code>${this._sym}</code> (line <code>${this._sym.line}</code>)`);else throw new Error(`Unexpected end of input (line <code>${this._sym.line}</code>)`)}_exponent(){const a=[this._factor()];for(;this._match(Ro_Token.POW);)this._nextSym(),a.push(this._factor());return new Ro_Parser._Exponent(a)}_term(){const a=[this._exponent()];for(;this._match(Ro_Token.MULT)||this._match(Ro_Token.DIV);)a.push(this._nextSym()),a.push(this._exponent());return new Ro_Parser._Term(a)}_expression(){const a=[];for((this._match(Ro_Token.ADD)||this._match(Ro_Token.SUB))&&a.push(this._nextSym()),a.push(this._term());this._match(Ro_Token.ADD)||this._match(Ro_Token.SUB);)a.push(this._nextSym()),a.push(this._term());return new Ro_Parser._Expression(a)}_condition(){const a=[];return this._match(Ro_Token.NOT)&&a.push(this._nextSym()),a.push(this._expression()),(this._match(Ro_Token.EQ)||this._match(Ro_Token.NE)||this._match(Ro_Token.GT)||this._match(Ro_Token.LT)||this._match(Ro_Token.GTEQ)||this._match(Ro_Token.LTEQ))&&(a.push(this._nextSym()),a.push(this._expression())),new Ro_Parser._Condition(a)}_statement(){const a=[];if(this._match(Ro_Token.TYP_NUMBER)||this._match(Ro_Token.ADD)||this._match(Ro_Token.SUB)||this._match(Ro_Token.PAREN_OPEN))a.push(this._expression()),this._expect(Ro_Token.NEWLINE);else if(this._match(Ro_Token.TYP_IDENTIFIER))this._peek()===Ro_Token.ASSIGN?(a.push(this._accept(Ro_Token.TYP_IDENTIFIER)),this._expect(Ro_Token.ASSIGN),a.push(this._expression())):a.push(this._expression()),this._expect(Ro_Token.NEWLINE);else if(this._accept(Ro_Token.IF)){for(a.push(this._lastAccepted),a.push(this._condition()),this._expect(Ro_Token.COLON),this._accept(Ro_Token.NEWLINE)?a.push(this._block()):a.push(this._statement());this._accept(Ro_Token.ELIF);)a.push(this._lastAccepted),a.push(this._condition()),this._expect(Ro_Token.COLON),this._accept(Ro_Token.NEWLINE)?a.push(this._block()):a.push(this._statement());this._accept(Ro_Token.ELSE)&&(a.push(this._lastAccepted),this._expect(Ro_Token.COLON),this._accept(Ro_Token.NEWLINE)?a.push(this._block()):a.push(this._statement()))}else throw new Error(`Syntax error: <code>${this._sym}</code> (line <code>${this._sym.line}</code>)`);return new Ro_Parser._Statement(a)}_block(){if(!this._syms.length)return new Ro_Parser._Block([]);if(this._accept(Ro_Token.INDENT)){const a=[];for(;!this._match(Ro_Token.DEDENT);)a.push(this._statement()),this._match(Ro_Token.INDENT)&&a.push(this._block());return this._expect(Ro_Token.DEDENT),new Ro_Parser._Block(a)}else{const a=[];for(;this._sym;)a.push(this._statement()),this._match(Ro_Token.INDENT)&&a.push(this._block());return new Ro_Parser._Block(a)}}}Ro_Parser._AbstractSymbol=class{static _indent(a,b){return`${" ".repeat(2*b)}${a}`}constructor(){this.type=Ro_Token.TYP_SYMBOL}eq(a){return a&&this.type===a.type}pEvl(){throw new Error("Unimplemented!")}toString(){throw new Error("Unimplemented!")}},Ro_Parser._Factor=class extends Ro_Parser._AbstractSymbol{constructor(a,b){super(),b=b||{},this._node=a,this._hasParens=!!b.hasParens}pEvl(a,b){switch(this._node.type){case Ro_Token.TYP_IDENTIFIER:return{val:+a[this._node.value]};case Ro_Token.TYP_NUMBER:return{val:+this._node.value};case Ro_Token.TYP_DYNAMIC:return Ro_Lang.pResolveDynamic(this._node,b);case Ro_Token.TYP_SYMBOL:return this._node.pEvl(a,b);default:throw new Error(`Unimplemented!`);}}toString(a=0){let b;switch(this._node.type){case Ro_Token.TYP_IDENTIFIER:b=this._node.value;break;case Ro_Token.TYP_NUMBER:b=this._node.value;break;case Ro_Token.TYP_DYNAMIC:b=`await Char_Lang.pResolveDynamic("${(this._node.value||"").replace(/"/g,`\\"`)}")`;break;case Ro_Token.TYP_SYMBOL:b=this._node.toString(a);break;default:throw new Error(`Unimplemented!`);}return this._hasParens?`(${b})`:b}},Ro_Parser._Exponent=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a}async pEvl(a,b){var c=Math.pow;const d=this._nodes.slice(),e=await d.pop().pEvl(a,b);if(e.isCancelled)return e;for(let f=null;d.length;){if(f=await d.pop().pEvl(a,b),f.isCancelled)return f;e.val=c(f.val,e.val)}return e}toString(a=0){const b=this._nodes.slice();let c=b.pop().toString(a);for(;b.length;)c=`Math.pow(${b.pop().toString(a)}, ${c})`;return c}},Ro_Parser._Term=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a}async pEvl(a,b){const c=await this._nodes[0].pEvl(a,b);if(c.isCancelled)return c;let d;for(let e=1;e<this._nodes.length;e+=2)if(this._nodes[e].eq(Ro_Token.MULT)){if(d=await this._nodes[e+1].pEvl(a,b),d.isCancelled)return d;c.val*=d.val}else if(this._nodes[e].eq(Ro_Token.DIV)){if(d=await this._nodes[e+1].pEvl(a,b),d.isCancelled)return d;c.val/=d.val}else throw new Error(`Unimplemented!`);return c}toString(a=0){let b=this._nodes[0].toString(a);for(let c=1;c<this._nodes.length;c+=2)if(this._nodes[c].eq(Ro_Token.MULT))b+=` * ${this._nodes[c+1].toString(a)}`;else if(this._nodes[c].eq(Ro_Token.DIV))b+=` / ${this._nodes[c+1].toString(a)}`;else throw new Error(`Unimplemented!`);return b}},Ro_Parser._Expression=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a}async pEvl(a,b){const c=this._nodes.slice();let d=!1;(c[0].eq(Ro_Token.ADD)||c[0].eq(Ro_Token.SUB))&&(d=c.shift().eq(Ro_Token.SUB));const e=await c[0].pEvl(a,b);if(e.isCancelled)return e;d&&(e.val=-e.val);let f;for(let d=1;d<c.length;d+=2)if(c[d].eq(Ro_Token.ADD)){if(f=await c[d+1].pEvl(a,b),f.isCancelled)return f;e.val+=f.val}else if(c[d].eq(Ro_Token.SUB)){if(f=await c[d+1].pEvl(a,b),f.isCancelled)return f;e.val-=f.val}else throw new Error(`Unimplemented!`);return e}toString(a=0){let b="";const c=this._nodes.slice();let d=!1;(c[0].eq(Ro_Token.ADD)||c[0].eq(Ro_Token.SUB))&&(d=c.shift().eq(Ro_Token.SUB),d&&(b+="-")),b+=c[0].toString(a);for(let d=1;d<c.length;d+=2)if(c[d].eq(Ro_Token.ADD))b+=` + ${c[d+1].toString(a)}`;else if(c[d].eq(Ro_Token.SUB))b+=` - ${c[d+1].toString(a)}`;else throw new Error(`Unimplemented!`);return b}},Ro_Parser._Condition=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a,this._isNegated=this._nodes[0].eq(Ro_Token.NOT),this._cleanNodes=this._nodes.slice(),this._isNegated&&this._cleanNodes.shift()}async pEvl(a,b){const c={isCancelled:!1,val:null};if(3===this._cleanNodes.length){const[d,e,f]=this._cleanNodes,g=await d.pEvl(a,b);if(g.isCancelled)return g;const h=await f.pEvl(a,b);if(h.isCancelled)return h;switch(e.type){case Ro_Token.EQ.type:c.val=g.val===h.val;break;case Ro_Token.NE.type:c.val=g.val!==h.val;break;case Ro_Token.GT.type:c.val=g.val>h.val;break;case Ro_Token.LT.type:c.val=g.val<h.val;break;case Ro_Token.GTEQ.type:c.val=g.val>=h.val;break;case Ro_Token.LTEQ.type:c.val=g.val<=h.val;break;default:throw new Error(`Unimplemented!`);}}else if(1===this._cleanNodes.length){const d=await this._cleanNodes[0].pEvl(a,b);if(d.isCancelled)return d;c.val=d.val}else throw new Error(`Invalid node count!`);return this._isNegated&&(c.val=!c.val),c}toString(a=0){let b="";if(3===this._cleanNodes.length){const[c,d,e]=this._nodes,f=c.toString(a),g=e.toString(a);switch(d.type){case Ro_Token.EQ.type:b+=`${f} === ${g}`;break;case Ro_Token.NE.type:b+=`${f} !== ${g}`;break;case Ro_Token.GT.type:b+=`${f} > ${g}`;break;case Ro_Token.LT.type:b+=`${f} < ${g}`;break;case Ro_Token.GTEQ.type:b+=`${f} >= ${g}`;break;case Ro_Token.LTEQ.type:b+=`${f} <= ${g}`;break;default:throw new Error(`Unimplemented!`);}}else if(1===this._cleanNodes.length)b+=this._cleanNodes[0].toString(a);else throw new Error(`Invalid node count!`);return this._isNegated?`!${b}`:b}},Ro_Parser._Statement=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a}async pEvl(a,b){switch(this._nodes[0].type){case Ro_Token.TYP_SYMBOL:return this._nodes[0].pEvl(a,b);case Ro_Token.TYP_IDENTIFIER:{const[c,d]=this._nodes,e=await d.pEvl(a,b);if(e.isCancelled)return e;return a[c.value]=e.val,e}case Ro_Token.IF.type:return this._pEvl_pIfElse(a,b);default:throw new Error(`Unimplemented!`);}}async _pEvl_pIfElse(a,b){const c=[];for(let d=0;d<this._nodes.length;++d)switch(this._nodes[d].type){case Ro_Token.IF.type:case Ro_Token.ELIF.type:{c.push({condition:this._nodes[d+1],toEvl:this._nodes[d+2]}),d+=2;break}case Ro_Token.ELSE.type:{c.push({toEvl:this._nodes[d+1]}),d+=1;break}}for(const d of c)if(null==d.condition)return d.toEvl.pEvl(a,b);else{const c=await d.condition.pEvl(a,b);if(c.isCancelled)return c;if(c.val)return d.toEvl.pEvl(a,b)}return{isCancelled:!1,val:null}}toString(a=0){switch(this._nodes[0].type){case Ro_Token.TYP_SYMBOL:return Ro_Parser._AbstractSymbol._indent(`return ${this._nodes[0].toString()}\n`,a);case Ro_Token.TYP_IDENTIFIER:{const[b,c]=this._nodes;return Ro_Parser._AbstractSymbol._indent(`var ${b.value} = ${c.toString(a)}\n`,a)}case Ro_Token.IF.type:return this._toString_ifElse(a);default:throw new Error(`Unimplemented!`);}}_toString_ifElse(a){let b="";for(let c=0;c<this._nodes.length;++c)switch(this._nodes[c].type){case Ro_Token.IF.type:case Ro_Token.ELIF.type:{b+=`${this._nodes[c].eq(Ro_Token.IF)?"if ":"else if "}`,b+=`(${this._nodes[c+1].toString(a)}) {\n`,b+=`${this._nodes[c+2].toString(a+1)}`,b+=`}\n`,c+=2;break}case Ro_Token.ELSE.type:{b+=`else {\n`,b+=`${this._nodes[c+1].toString(a+1)}`,b+=`}\n`,c+=1;break}}return b}},Ro_Parser._Block=class extends Ro_Parser._AbstractSymbol{constructor(a){super(),this._nodes=a}async pEvl(a,b){for(const c of this._nodes){const d=await c.pEvl(a,b);if(d.isCancelled)return d;if(null!=d.val)return d}return{isCancelled:!1,val:null}}toString(a=0){return this._nodes.map(b=>b.toString(a)).join("")}};class Ro_Lang{static async pValidate(a,b){const c=new Ro_Lexer;let d;try{d=c.lex(a)}catch(a){return a.message}for(const c of d)if(c.type===Ro_Token.TYP_DYNAMIC)try{await Ro_Lang.pResolveDynamic(c,b,{isValidateOnly:!0})}catch(a){return a.message}const e=new Ro_Parser(d);try{e.parse()}catch(a){return a.message}return null}static pRun(a,b,c){const d=MiscUtil.copy(b),e=new Ro_Lexer,f=e.lex(a),g=new Ro_Parser(f),h=g.parse();return h.pEvl(d,c)}static async pResolveDynamics(a,b){const c=new Ro_Lexer,d=c.lex(a,{isDynamicsOnly:!0});let e="";for(const c of d)switch(c.type){case Ro_Token.TYP_UNPARSED:e+=c.value;break;case Ro_Token.TYP_DYNAMIC:e+=(await this.pResolveDynamic(c,b)).val;break;case Ro_Token.NEWLINE.type:e+="\n";break;default:throw new Error(`Unhandled token type: ${c.type}`);}return e}static async pValidateDynamics(a,b){const c=new Ro_Lexer,d=c.lex(a,{isDynamicsOnly:!0});for(const c of d)if(c.type===Ro_Token.TYP_DYNAMIC){const a=await this.pResolveDynamic(c,b,{isValidateOnly:!0});if(a)return a}return null}static pResolveDynamic(a,b,c){c=c||{};const d=b=>`Unknown property: <code>${b}</code> (line <code>${a.line}</code>)`,e=a.value.replace(/^\(?@(.*?)\)?$/,"$1"),[f,...g]=e.split("|").map(a=>a.trim());for(;g.length&&!g.last();)g.pop();switch(f){case"user_int":return this._pResolveDynamic_getUserInt(a,g,c);case"user_bool":return this._pResolveDynamic_getUserBool(a,g,c);default:{if(c.isValidateOnly)return b.has(f)?null:d(f);if(b.has(f))return{isCancelled:!1,val:b.get(f)};throw new Error(d(f))}}}static async _pResolveDynamic_getUserInt(a,b,c){c=c||{};const d={isCancelled:!1,val:null};if(1>=b.length){if(c.isValidateOnly)return;const a={int:!0};b.length&&(a.title=b[0].trim());const e=await InputUiUtil.pGetUserNumber(a);null==e?d.isCancelled=!0:d.val=e}else{const e=b[0].trim(),f=b.slice(1).map(b=>{const c=b.split("=").map(a=>a.trim()),d=+c[0];if(isNaN(d))throw new Error(`Syntax error: Option <code>${c[0]}</code> was not a number (line <code>${a.line}</code>)`);if(1===c.length)return{label:d,val:d};if(2===c.length)return{label:c[1],val:d};throw new Error(`Syntax error: option <code>${b}</code> was not formatted correctly (line ${a.line})`)});if(c.isValidateOnly)return;const g=await InputUiUtil.pGetUserEnum({fnDisplay:a=>a.label,values:f,title:e});null==g?d.isCancelled=!0:d.val=f[g].val}return d}static async _pResolveDynamic_getUserBool(a,b,c){c=c||{};const d={isCancelled:!1,val:null};if(1>=b.length){if(c.isValidateOnly)return;const a={};b.length&&(a.title=b[0].trim());const e=await InputUiUtil.pGetUserBoolean(a);null==e?d.isCancelled=!0:d.val=e}else if(3===b.length){if(c.isValidateOnly)return;const a={title:b[0].trim(),textYes:b[1].trim(),textNo:b[2].trim()},e=await InputUiUtil.pGetUserBoolean(a);null==e?d.isCancelled=!0:d.val=e}else{const e=b[0].trim(),f=b.slice(1).map(b=>{const c=b.split("=").map(a=>a.trim()),d=UiUtil.strToBool(c[0],null);if(null==d)throw new Error(`Syntax error: Option <code>${c[0]}</code> was not a boolean (line <code>${a.line}</code>`);if(1===c.length)return{label:d,val:d};if(2===c.length)return{label:c[1],val:d};throw new Error(`Syntax error: option <code>${b}</code> was not formatted correctly (line ${a.line})`)});if(c.isValidateOnly)return;const g=await InputUiUtil.pGetUserEnum({fnDisplay:a=>a.label,values:f,title:e});null==g?d.isCancelled=!0:d.val=f[g].val}return d}}export{Ro_Token,Ro_Lexer,Ro_Parser,Ro_Lang};